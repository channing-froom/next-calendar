{"version":3,"file":"static/webpack/static/development/pages/search.js.e83d789eb768787152d3.hot-update.js","sources":["webpack:///./lib/services/SearchService.js"],"sourcesContent":["import Router from 'next/router';\nimport fetch from 'isomorphic-fetch';\n\nexport default class SearchService {\n\n    /**\n     * create a new search request\n     * \n     * @param Date startDate \n     * @param Date endDate \n     */\n    static Search(startDate, endDate) {\n        // will throw exception if fails\n        this.ValidateDateRange(startDate, endDate);\n        this.Go(startDate, endDate);\n    }\n\n    /**\n     * Send user to the search page\n     * \n     * @param Date startDate \n     * @param Date endDate \n     */\n    static Go(startDate, endDate)\n    {\n        Router.push({\n            pathname: '/search',\n            query: {\n                start: this.FormatDate(startDate),\n                end: this.FormatDate(endDate)\n            }\n          });\n    }\n\n    /**\n     * Formate the date into the required shape\n     * This works well for passing SEO type values through the URI\n     * \n     * @param Date value \n     */\n    static FormatDate(value) {\n        return new Date(value).toISOString().slice(0,10)\n    }\n\n    /**\n     * Generate a api url for this date\n     * \n     * @param Date date \n     */\n    static GetApiUrlForDate(date)\n    {\n        const value = date.toISOString().slice(5,10).replace('-', '/');\n        const url = process.env.NODE_ENV != \"production\"\n            ? \"http://numbersapi.com\"\n            : \"https://react-calendar-numbers.froomiethought.co.za\";\n\n        return `http://numbersapi.com/${value}/date`;\n    }\n\n    static async CollectNotes(days)\n    {\n        var notes = [];\n\n        for(let i = 0; i < days.length; i++) {\n            const response = await fetch(this.GetApiUrlForDate(days[i]), {cache: \"force-cache\"})\n                .then(response => {\n                    // THERE SHOULD BE ERROR HANDLING HERE !!!\n                    return response.text();\n                })\n                .then(response => {\n                    notes.push(\n                        this.FormatNote(response, days[i])\n                    );\n                })\n                .catch(e => {console.log(e)});\n        }\n\n        return notes;\n    }\n\n    static FormatNote(note, date)\n    {\n        const months = ['January','February','March','April','May','June',\n                'July','August','September','October','November','December'];\n\n        const month = months[date.getMonth()],\n            day = date.getDate();\n\n        const nth = this.GetDateNt(day);\n        const dateString = `${month} ${day}${nth}`;\n        const noteString = note.replace(dateString, '');\n\n        return {\n            date: dateString,\n            note: noteString\n        };\n        \n    }\n\n    static GetDateNt(day)\n    {\n        if (day > 3 && day < 21) return 'th'; \n        switch (day % 10) {\n            case 1:  return \"st\";\n            case 2:  return \"nd\";\n            case 3:  return \"rd\";\n            default: return \"th\";\n        }\n    }\n\n    /**\n     * Validate a date range\n     * \n     * @param Date dateFrom \n     * @param Date dateTo \n     * @param bool throwException \n     */\n    static ValidateDateRange(dateFrom, dateTo, throwException = true) {\n        try {\n            this.ValidateDate(dateFrom);\n            this.ValidateDate(dateTo);\n        } catch (e) {\n            if (!throwException) {\n                return false;\n            }\n\n            throw e;\n        }\n\n        return true;\n    }\n\n    /**\n     * Simple check to see if the value passed is what we expect\n     * This is not a production ready function !\n     * \n     * @param Date value \n     */\n    static ValidateDate(value)\n    {\n        if (!value) {\n            throw \"Please provide all dates\";\n        } else if (!value instanceof Date) {\n            throw `Value passed is not a date ${value}`;\n        }\n    }\n\n    static IsMonday(date)\n    {\n        return date.getDay() === 1;\n    }\n\n    static HasLeapYear(years)\n    {\n        for (let i = 0; i < years.length; i++) {\n            if (new Date(years[i], 1, 29).getDate() === 29) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    static async CollectDateItems(dateFrom, dateTo) {\n        console.log(`running search on ${process.env.NODE_ENV}`);\n\n        let days = [];\n        let years = [];\n        let mondays = 0;\n        dateFrom = new Date(dateFrom);\n        dateTo = new Date(dateTo);\n\n        // Resolve time difference so we can create a linear search\n        let current = dateFrom.getTime() < dateTo.getTime() ? dateFrom : dateTo;\n        const end = dateFrom.getTime() > dateTo.getTime() ? dateFrom : dateTo;\n        const endTime = end.getTime();\n        \n        // push the first item onto the array\n        days.push(new Date(current));\n\n        if (this.IsMonday(current)) {\n            mondays++;\n        }\n\n        // Create a array of all the values between\n        while (endTime > current.getTime()) {\n            days.push(current);\n\n            if (this.IsMonday(current)) {\n                mondays++;\n            }\n\n            // check to see if we tracking these years or not            \n            if (!years.includes(current.getFullYear())) {\n                years.push(current.getFullYear());\n            }\n\n            current = new Date(current.setDate(current.getDate() + 1));\n        }\n\n        return {\n            daysApart: days.length,\n            amountOfMondays: mondays,\n            hasLeapYear: this.HasLeapYear(years),\n            notes: await this.CollectNotes(days)\n        };\n    }\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AAMA;AAEA;AACA;AACA;AACA;AACA;AAFA;AAFA;AAOA;AAEA;;;;;;;;;AAMA;AACA;AACA;AAEA;;;;;;;;AAKA;AAEA;AACA;AAIA;AACA;;;;;;AAEA;;;;;;;;;AAEA;;;AAEA;;;;;;;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAAA;AACA;;AAXA;AACA;;;;;;;;AAFA;AACA;;AADA;;;;;AAAA;AACA;;AADA;;;;;AAcA;AACA;;;;;;;;;;;;;;;;;AAEA;AAEA;AAGA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAKA;;;AAEA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAJA;AAMA;AAEA;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAEA;AACA;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;;;;AAJA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;A","sourceRoot":""}